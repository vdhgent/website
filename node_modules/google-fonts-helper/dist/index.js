'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const path = require('path');
const url = require('url');
const querystring = require('querystring');
const fsExtra = require('fs-extra');
const deepmerge = require('deepmerge');
const got = require('got');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const got__default = /*#__PURE__*/_interopDefaultLegacy(got);

function isValidDisplay(display) {
  return ["auto", "block", "swap", "fallback", "optional"].includes(display);
}
function convertFamiliesObject(families) {
  const result = {};
  families.forEach((family) => {
    if (!family) {
      return;
    }
    if (!family.includes(":")) {
      result[family] = true;
      return;
    }
    const parts = family.split(":");
    if (!parts[1]) {
      return;
    }
    const values = {};
    let [styles, weights] = parts[1].split("@");
    if (!weights) {
      weights = String(styles).replace(",", ";");
      styles = "wght";
    }
    styles.split(",").forEach((style) => {
      values[style] = weights.split(";").map((weight) => {
        if (/^\+?\d+$/.test(weight)) {
          return parseInt(weight);
        }
        const [pos, w] = weight.split(",");
        const index = style === "wght" ? 0 : 1;
        if (parseInt(pos) === index && /^\+?\d+$/.test(w)) {
          return parseInt(w);
        }
        return 0;
      }).filter((v) => v > 0);
      values[style] = Object.entries(values[style]).length > 0 ? values[style] : true;
    });
    result[parts[0]] = values;
  });
  return result;
}
function convertFamiliesToArray(families) {
  const result = [];
  Object.entries(families).forEach(([name, values]) => {
    if (!name)
      return;
    if (Array.isArray(values) && values.length > 0) {
      result.push(`${name}:wght@${values.join(";")}`);
      return;
    }
    if (Object.keys(values).length > 0) {
      const styles = [];
      const weights = [];
      Object.entries(values).sort(([styleA], [styleB]) => styleA.localeCompare(styleB)).forEach(([style, weight]) => {
        styles.push(style);
        (Array.isArray(weight) ? weight : [weight]).forEach((value) => {
          if (Object.keys(values).length === 1 && style === "wght") {
            weights.push(String(value));
          } else {
            const index = style === "wght" ? 0 : 1;
            weights.push(`${index},${value}`);
          }
        });
      });
      if (!styles.includes("wght")) {
        styles.push("wght");
      }
      const weightsSortered = weights.sort(([weightA], [weightB]) => weightA.localeCompare(weightB)).join(";");
      result.push(`${name}:${styles.join(",")}@${weightsSortered}`);
      return;
    }
    if (values) {
      result.push(name);
    }
  });
  return result;
}
function parseFontsFromCss(content, fontsPath) {
  const fonts = [];
  const re = {
    face: /\s*(?:\/\*\s*(.*?)\s*\*\/)?[^@]*?@font-face\s*{(?:[^}]*?)}\s*/gi,
    family: /font-family\s*:\s*(?:'|")?([^;]*?)(?:'|")?\s*;/i,
    weight: /font-weight\s*:\s*([^;]*?)\s*;/i,
    url: /url\s*\(\s*(?:'|")?\s*([^]*?)\s*(?:'|")?\s*\)\s*?/gi
  };
  let i = 1;
  let match1;
  while ((match1 = re.face.exec(content)) !== null) {
    const [fontface, comment] = match1;
    const familyRegExpArray = re.family.exec(fontface);
    const family = familyRegExpArray ? familyRegExpArray[1] : "";
    const weightRegExpArray = re.weight.exec(fontface);
    const weight = weightRegExpArray ? weightRegExpArray[1] : "";
    let match2;
    while ((match2 = re.url.exec(fontface)) !== null) {
      const [forReplace, url] = match2;
      const urlPathname = new URL(url).pathname;
      const ext = path.extname(urlPathname);
      if (ext.length < 2) {
        continue;
      }
      const filename = path.basename(urlPathname, ext) || "";
      const newFilename = formatFontFileName("{_family}-{weight}-{comment}{i}.{ext}", {
        comment: comment || "",
        family,
        weight: weight || "",
        filename,
        _family: family.replace(/\s+/g, "_"),
        ext: ext.replace(/^\./, "") || "",
        i: String(i++)
      }).replace(/\.$/, "");
      fonts.push({
        inputFont: url,
        outputFont: newFilename,
        inputText: forReplace,
        outputText: `url('${path.posix.join(fontsPath, newFilename)}')`
      });
    }
  }
  return fonts;
}
function formatFontFileName(template, values) {
  return Object.entries(values).filter(([key]) => /^[a-z0-9_-]+$/gi.test(key)).map(([key, value]) => [new RegExp(`([^{]|^){${key}}([^}]|$)`, "g"), `$1${value}$2`]).reduce((str, [regexp, replacement]) => str.replace(regexp, String(replacement)), template).replace(/({|}){2}/g, "$1");
}

class GoogleFontsHelper {
  constructor(fonts = {}) {
    this.fonts = fonts;
  }
  getFonts() {
    return this.fonts;
  }
  constructURL() {
    const {families, display, subsets, text} = this.fonts;
    const family = convertFamiliesToArray(families != null ? families : {});
    if (family.length < 1) {
      return false;
    }
    const query = {
      family
    };
    if (display && isValidDisplay(display)) {
      query.display = display;
    }
    const subset = (Array.isArray(subsets) ? subsets : [subsets]).filter(Boolean);
    if (subset.length > 0) {
      query.subset = subset.join(",");
    }
    if (text) {
      query.text = encodeURI(text);
    }
    return querystring.unescape(url.format({
      protocol: "https",
      hostname: "fonts.googleapis.com",
      pathname: query.subset ? "css" : "css2",
      query
    }));
  }
  merge(...values) {
    const newFonts = [this.fonts];
    values.forEach((value) => {
      newFonts.push(value instanceof GoogleFontsHelper ? value.getFonts() : value);
    });
    this.fonts = deepmerge.all(newFonts);
  }
  static isValidURL(url) {
    return /fonts.googleapis.com/.test(url);
  }
  static parse(url) {
    if (!GoogleFontsHelper.isValidURL(url)) {
      return new GoogleFontsHelper();
    }
    const {searchParams} = new URL(url);
    if (!searchParams.has("family")) {
      return new GoogleFontsHelper();
    }
    const result = {};
    const families = convertFamiliesObject(searchParams.getAll("family"));
    if (Object.keys(families).length < 1) {
      return new GoogleFontsHelper();
    }
    result.families = families;
    const display = searchParams.get("display");
    if (display && isValidDisplay(display)) {
      result.display = display;
    }
    const subsets = searchParams.get("subset");
    if (subsets) {
      result.subsets = subsets.split(",");
    }
    const text = searchParams.get("text");
    if (text) {
      result.text = decodeURI(text);
    }
    return new GoogleFontsHelper(result);
  }
  static async download(url, options) {
    var _a;
    if (!GoogleFontsHelper.isValidURL(url)) {
      throw new Error("Invalid Google Fonts URL");
    }
    const headers = {
      "user-agent": [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
        "AppleWebKit/537.36 (KHTML, like Gecko)",
        "Chrome/80.0.3987.132 Safari/537.36"
      ].join(" ")
    };
    const config = {
      base64: false,
      overwriting: false,
      outputDir: "./",
      stylePath: "fonts.css",
      fontsDir: "fonts",
      fontsPath: "./fonts",
      headers,
      ...options
    };
    const stylePath = path.resolve(config.outputDir, config.stylePath);
    const fontsDir = path.resolve(config.outputDir, config.fontsDir);
    if (!config.overwriting && fsExtra.pathExistsSync(stylePath)) {
      return;
    }
    let {body: css} = await got__default['default'](url, {headers: config.headers});
    const fonts = parseFontsFromCss(css, config.fontsPath);
    for (const font of fonts) {
      const response = got__default['default'](font.inputFont, {headers: config.headers});
      const buffer = await response.buffer();
      if (config.base64) {
        const mime = (_a = (await response).headers["content-type"]) != null ? _a : "font/woff2";
        const content = buffer.toString("base64");
        css = css.replace(font.inputText, `url('data:${mime};base64,${content}')`);
      } else {
        const fontPath = path.resolve(fontsDir, font.outputFont);
        await fsExtra.outputFile(fontPath, buffer);
        css = css.replace(font.inputText, font.outputText);
      }
    }
    await fsExtra.outputFile(stylePath, css);
  }
}

exports.GoogleFontsHelper = GoogleFontsHelper;
